#' BAS tag data processing
#'
#' Basic data processing for British Antarctic Survey archival tags.
#' Provides facilities for importing and plotting data recorded by the
#' BAS tags, and in particular detecting times of twilight from the
#' recorded light data.
#'
#' @name BAStag-package
#' @docType package
#' @author Simon Wotherspoon, Micheal Sumner and Simeon Lisovski.
NULL



## Data import


##' Read light data from a BAS tag
##'
##' The \code{read.lig} imports the light record from a ".lig" file
##' generated by a BAS tag.
##' @title Read Light Data
##' @param file the light file to import
##' @return Returns a dataframe with columns
##' \item{\code{Valid}}{an indicator of whether the record is valid}
##' \item{\code{Date}}{the date and time of the observation}
##' \item{\code{Julian}}{date and time as Julian date}
##' \item{\code{Light}}{the recorded light level}
##' @export
read.lig <- function(file) {
  ## Read csv file and add column names
  d <- read.csv(file,header=F,
                col.names=c("Valid","Date","Julian","Light"),
                colClasses=c("character","character","numeric","integer"))
  ## Parse date
  d$Date <- as.POSIXct(strptime(d$Date,"%d/%m/%y %H:%M:%S",tz="GMT"))
  d
}



##' Read the activity data from a BAS tag
##'
##' The \code{read.act} imports the light record from a ".act" file
##' generated by a BAS tag.
##'
##' @title Read Activity Data
##' @param file the activity file to import.
##' @return Returns a dataframe with columns
##' \item{\code{Valid}}{an indicator of whether the record is valid}
##' \item{\code{Date}}{the date and time of the observation}
##' \item{\code{Julian}}{date and time as Julian date}
##' \item{\code{Activity}}{the recorded activity level}
##' \item{\code{SST}}{the recorded sea surface temperature}
##' @export
read.act <- function(file) {
  ## Read csv file and add column names.  Must explicitly specify
  ## column names as R cannot detect the correct number of columns to
  ## read
  d <- read.csv(file,header=F,
                col.names=c("Valid","Date","Julian","Activity","SST"))
  ## Parse date
  d$Date <- as.POSIXct(strptime(d$Date,"%d/%m/%y %H:%M:%S",tz="GMT"))
  ## Add day number and time within day (as fraction of a day)
  d$Day <- floor(d$Julian)
  d$Time <- d$Julian-d$Day
  d
}



##' Utilities for manipulating hours
##'
##' Given a vector of POSIXct dates, \code{as.hour} extracts the time
##' of day component of the date and returns it as decimal hours.
##' Given a vector of decimal hours, \code{hour.offset} recodes the
##' decimal hour into a new 24 hour interval.
##' @title Hour Manipulation
##' @rdname hours
##' @param tm them timestamp as POSIXct
##' @param hr the decimal hour to be wrap
##' @param offset minimum hour of the interval to wrap into
##' @return Return a decimal hour.
##' @examples
##' as.hour(as.POSIXct("2005-11-12 19:58:00"))
##' hour.offset(1:10,5)
##' @export
as.hour <- function(tm) {
  (as.numeric(tm)-as.numeric(as.POSIXct(as.Date(tm))))/3600
}


##' @rdname hours
##' @export
hour.offset <-  function(hr,offset=0) {
  (hr-offset)%%24+offset
}


##' Display time series data as an image.
##'
##' The \code{tsimage} function divides a regular sequence of samples
##' into 24 hour periods, packs these into the columns of a matrix and
##' displays the result as an image.
##'
##' The \code{tsimage.locator} function allows the user to select
##' pixels with the mouse pointer in the style of \code{locator}, and
##' returns the times corresponding to the selected pixels.
##'
##' These functions ignore clock drift and assume the sampling period
##' exactly divides 24 hours.
##'
##' @title Display Tag Data as an Image
##' @param date the sequence of sample times as POSIXct.
##' @param y the sequence of responses
##' @param offset the starting hour for the vertical axis.
##' @param xlab the x axis label.
##' @param ylab the y axis label.
##' @param ... additional arguments to be passed to \code{image}
##' @param im the axes coordinates returned by \code{tsimage}
##' @param n the number of points to select
##' @return
##' \code{tsimage} returns the date and hour coordinates of the image
##' grid.
##' \code{tsimage.locator} returns the times corresponding to the
##' selected pixels.
##' @export
tsimage <- function(date,y,offset=0,xlab="Date",ylab="Hour",...) {

  ## Estimate sampling interval rounded to nearest minute
  dt <- 60*round(median(diff(as.numeric(date)))/60)
  ## Calculate number of rows m, number of columns n, and number of
  ## pixels to pad at front
  m <- 24*60*60/dt
  pad <- floor(((as.hour(date[1])-offset)%%24)*60*60/dt)
  n <- ceiling((length(y)+pad)/m)
  ## Hour of each row (strictly increasing)
  hour <- as.hour(seq(date[1]-pad*dt,by=dt,length=m))
  hour <- hour[1]+cumsum(c(0,diff(hour)%%24))
  ## Date of first pixel in each column.
  day <- seq(date[1]-pad*dt,by=m*dt,length=n+1)
  y <- matrix(c(rep(NA,pad),y,rep(NA,m*n-pad-length(y))),m,n)
  ## Show as image, with hours wrapped to [0,24].
  image(day,hour,t(y),axes=F,xlab=xlab,ylab=ylab,...)
  axis.POSIXct(1,day)
  axis(2,at=seq(0,48,by=4),labels=seq(0,48,by=4)%%24)
  box()
  invisible(list(date=day,hour=hour,offset=hour[1]-dt/2))
}

##' @rdname tsimage
##' @export
tsimage.locator <- function(im,n=512) {
  ## Force evaluation of im.
  im <- im
  ## Select pixels and convert to date/time.
  loc <- locator(n)
  im$date[.bincode(loc$x,as.numeric(im$date),right=F)]+3600*(loc$y-min(im$hour))
}


##' Plot times as hour vs date
##'
##' Analogs of \code{plot}, \code{points} and \code{lines} that plot
##' the time of day against date.
##' @title tsimage plot
##' @param date times as a vector of POSIXct
##' @param offset the starting hour for the vertical axes.
##' @param xlab the label for the x axis.
##' @param ylab the label for the y axis.
##' @param ... additional arguments parameters to pass to \code{plot},
##' \code{points} or \code{lines}
##' @export
tsimage.plot <- function(date,offset,xlab="Date",ylab="Hour",...) {
  plot(date,hour.offset(as.hour(date),offset%%24),xlab=xlab,ylab=ylab,...)
}

##' @rdname tsimage.plot
##' @export
tsimage.points <- function(date,offset,...) {
  points(date,hour.offset(as.hour(date),offset%%24),...)
}

##' @rdname tsimage.plot
##' @export
tsimage.lines <- function(date,offset,...) {
  lines(date,hour.offset(as.hour(date),offset%%24),...)
}



##' Display light series as an image.
##'
##' The \code{light.image} function displays sequence of light
##' samples into 24 hour periods, packs these into the columns of a
##' matrix and displays the result as an image.
##'
##' This function is essentially a wrapper for \code{tsimage}.
##' @title Display Light Data as an Image
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param offset the offset for the vertical axis in hours.
##' @param zmax the maximum light level
##' @param xlab the x axis label.
##' @param ylab the y axis label.
##' @param ...  additional arguments to pass to image.
##' @return Returns the date and hour coordinates of the image grid.
##' @export
light.image <- function(tagdata,offset=0,zmax=64,xlab="Date",ylab="Hour",...) {

  tsimage(tagdata$Date,tagdata$Light,offset,
          zlim=c(0,zmax),col=grey(seq(0,1,length=64)),
          xlab=xlab,ylab=ylab,...)
}


##' Search for pairs of twilights spanning night.
##'
##' Search for sunset, sunrise pairs that correspond to a given light
##' threshold.
##'
##' Given a set of times (\code{include}) known to fall in the night,
##' \code{find.twilights} determines the twilights that span these times, and
##' computes the corresponding midnights. It then searches for periods
##' of darkness that lie approximately 24 hours from these midnights,
##' repeating the process until no new twilight pairs are found.
##'
##' If \code{interleave=TRUE}, the sunrise and sunset times are
##' interleaved andreturned as a single sequence of twilights,
##' otherwise sunset and sunrise times are returned separately. The
##' function \code{interleave.twilights} takes a dataframe of separate
##' sunset and sunrise times and interleaves them to form a sequence
##' of twilight times.
##'
##' @title Search for twilight times
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param threshold the light threshold that defines twilight.
##' @param include a vector of times as POSIXct. Nights that span these
##' times are included in the search.
##' @param exclude a vector of POSIXct times. Nights that span these
##' times are excluded from the search.
##' @param extend a time in minutes. The function seeks periods of
##' darkness that differ from one another by 24 hours plus or minus
##' this interval.
##' @param dark.min a time in minutes. Periods of darkness shorter
##' than this interval will be excluded.
##' @return A dataframe with columns
##' \item{\code{Twilight}}{times of twilight}
##' \item{\code{Rise}}{logical indicating sunrise}
##' where each row corresponds to a single twilight.
##' @export
find.twilights <- function(tagdata,threshold,include,
                           exclude=NULL,extend=0,dark.min=0) {
  ## Extract date and light data
  date <- tagdata$Date
  light <- tagdata$Light


  ## Is any x in each [a,b]
  contains.any <- function(a,b,x) {
    f <- logical(length(a))
    for(k in seq_along(x))
      f <- f | (a <= x[k] & b >= x[k])
    f
  }

  ## Convert to minutes
  extend <- 60*extend
  dark.min <- 60*dark.min

  ## Calculate intervals [a,b] of darkness
  ## a is first points before light drops below threshold
  ## b is first points before light rises to or above threshold
  l <- (light>=threshold)
  f <- diff(l)
  a <- which(f==-1)
  b <- which(f==1)
  ## Keep only fall-rise pairs
  if(b[1] < a[1]) b <- b[-1]
  a <- a[1:length(b)]

  ## Only keep intervals that do not include excluded data and are
  ## less than 24 hours in length
  keep <- (!contains.any(date[a],date[b+1],exclude) &
           (as.numeric(date[b+1])-as.numeric(date[a]) < 86400) &
           (as.numeric(date[b+1])-as.numeric(date[a]) > dark.min))

  a <- a[keep]
  b <- b[keep]

  ## Compute bounding dates and midpoint
  aDate <- date[a]
  bDate <- date[b+1]
  mDate <- aDate+(bDate-aDate)/2

  ## Iteratively expand set of twilights by searching for additional
  ## twilights +/- 24 hrs from midpoints of existing set.
  keep <- logical(length(a))
  add <- contains.any(aDate,bDate,include) & !keep
  while(any(add)) {
    keep <- keep | add
    mid <- c(mDate[add]-86400,mDate[add]+86400)
    add <- contains.any(aDate-extend,bDate+extend,mid) & !keep
  }
  a <- a[keep]
  b <- b[keep]

  ## Interpolate times to get exact twilights.
  ss <- date[a]+(threshold-light[a])/(light[a+1]-light[a])*(date[a+1]-date[a])
  sr <- date[b]+(threshold-light[b])/(light[b+1]-light[b])*(date[b+1]-date[b])


  data.frame(Twilight=.POSIXct(as.vector(t(cbind(ss,sr))),"GMT"),
             Rise=rep(c(F,T),length(ss)))
}





##' Search for crepuscular intervals
##'
##' Using the twilights calculated by \code{find.twilights},
##' \code{find.crepuscular} searchs for the intervals of reduced light
##' intensity around twilight and returns the dataframe constructed by
##' \code{find.twilights} augmented with the start and end times of
##' the crepuscular segment. The sugset of data corresponding to these
##' segments can be extracted with \code{extract.crepuscular}.
##'
##' @title Search for crepuscular light segments
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights a dataframe generated by
##' \code{\link{find.twilights}}.
##' @param min.threshold the light level that defines the dark end of
##' the crepuscular period
##' @param max.threshold the light level that defines the light end of
##' the crepuscular period
##' @param extend.dark the number of hours to search towards midnight.
##' @param extend.light the number of hours to search towards noon.
##' @return A dataframe with columns.
##' \item{\code{Twilight}}{times of twilight}
##' \item{\code{Rise}}{logical indicating sunrise}
##' \item{\code{Start}}{the start of the crepuscular period}
##' \item{\code{End}}{the end of the crepuscular period}
##' where each row corresponds to a single twilight.
##' @export
find.crepuscular <- function(tagdata,twilights,
                             min.threshold=0,max.threshold=60,
                             extend.dark=1,extend.light=2) {

  runlength <- function(x) {
    y <- cumsum(x)
    y-cummax(ifelse(!x,y,0))
  }

  ## Extract date and light
  date <- tagdata$Date
  light <- tagdata$Light

  twilight <- twilights$Twilight
  rise <- twilights$Rise
  start <- twilight
  end <-twilight
  ks <- findInterval(twilight,date)

  ## Loop over twilights
  for(i in seq_along(twilight)) {
    if(rise[i]) {
      ## Search forward to noon
      k <- ks[i]
      ls <- light[date > date[k] & date <= date[k]+extend.light*60*60]
      end[i] <- date[k+min(which(ls >= max.threshold),length(ls))]
      ## Search backward to midnight
      k <- ks[i]+1
      ls <- light[date <= date[k] & date >= date[k]-extend.dark*60*60]
      rs <- rev(runlength(ls==0))
      start[i] <- date[k+1-min(which(rs>=min(max(rs),4)))]
    } else {
      ## Search backward to noon
      k <- ks[i]+1
      ls <- light[date < date[k] & date >= date[k]-extend.light*60*60]
      start[i] <- date[k-min(which(rev(ls) >= max.threshold),length(ls))]
      ## Search forward to midnight
      k <- ks[i]
      ls <- light[date >= date[k] & date <= date[k]+extend.dark*60*60]
      rs <- rev(runlength(rev(ls)==0))
      end[i] <- date[k-1+min(which(rs>=min(max(rs),4)))]
    }
  }

  data.frame(Twilight=twilight,
             Rise=rise,
             Start=start,
             End=end)
}




##' Extract crepuscular light segments
##'
##' Extract the crepuscular subsets of the light data, given a
##' dataframe of start and end points generated by
##' \code{\link{find.crepuscular}}.
##'
##' The \code{adjust.interval} argument can be used to specify a
##' timing adjustment for tags that report the maximum light level
##' observed in the preceeding sampling interval. If this argument is
##' zero, no adjustment is made, otherwise the timestamps of sunset
##' intervals will be adjusted by this interval to compensate for the
##' recording behaviour of the tag.
##'
##' @title Extract crepuscular light segments
##' @param tagdata a dataframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights a dataframe generated by
##' \code{\link{find.crepuscular}}.
##' @param adjust.interval timing adjustment for sunset intervals
##' @return Returns a dataframe with columns
##' \item{\code{Date}}{the date and time of the observation}
##' \item{\code{Light}}{the recorded light level}
##' \item{\code{Segment}}{an integer identifying the segment}
##' @export
crepuscular.extract <- function(tagdata,twilights,adjust.interval=0) {
  date <- vector(mode="list",nrow(twilights))
  lght <- vector(mode="list",nrow(twilights))
  sgmt <- vector(mode="list",nrow(twilights))
  for(k in seq_len(nrow(twilights))) {
    is <- which(tagdata$Date >= twilights$Start[k] &
                tagdata$Date <= twilights$End[k])
    off <- if(!twilights$Rise[k]) adjust.interval else 0
    date[[k]] <- tagdata$Date[is]-off
    lght[[k]] <- tagdata$Light[is]
    sgmt[[k]] <- rep(k,length.out=length(is))
  }
  data.frame(Date=unlist(date),
             Light=unlist(lght),
             Segment=unlist(sgmt))
}






##' Find intervals of darkness spanning more than 24 hours.
##'
##' The \code{\link{find.twilights}} function find twilight times by
##' searching for adjacent nights, but is unable to search beyond a
##' period of darkness spaaning greater than 24 hours.  This function
##' finds extended periods of darkness that span more than 24 hours.
##' @title Find extended periods of darkness
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param threshold the light threshold that defines twilight.
##' @return A dataframe with one row for each intervals and columns
##' \item{\code{Start}}{the start of the interval as POSIXct}
##' \item{\code{Start}}{the end of the interval as POSIXct}
##' \item{\code{Midpoint}}{the midpoint of the interval as POSIXct}
##' @export
find.dark24 <- function(tagdata,threshold) {

  ## Extract date and light data
  date <- tagdata$Date
  light <- tagdata$Light



  ## Calculate intervals [a,b] of darkness
  ## a is first points before light drops below threshold
  ## b is first points before light rises to or above threshold
  l <- (light>=threshold)
  f <- diff(l)
  a <- which(f==-1)
  b <- which(f==1)
  ## Keep only fall-rise pairs
  if(b[1] < a[1]) b <- b[-1]
  a <- a[1:length(b)]

  ## Only keep intervals that span greater than 24 hours
  keep <- (as.numeric(date[b+1])-as.numeric(date[a]) >= 86400)
  a <- a[keep]
  b <- b[keep]
  data.frame(Start=date[a],
             End=date[b+1],
             Midpoint=date[a] + (date[b+1]-date[a])/2)
}




##' Find intervals of darkness spanning more than 24 hours.
##'
##' The \code{\link{find.twilights}} function find twilight times by
##' searching for adjacent nights, but is unable to search beyond a
##' period of light or dark spaaning greater than 24 hours.  This function
##' finds extended periods of light or dark that span more than 24 hours.
##' @title Find extended periods of light or dark
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param threshold the light threshold that defines twilight.
##' @return A dataframe with one row for each intervals and columns
##' \item{\code{Start}}{the start of the interval as POSIXct}
##' \item{\code{Start}}{the end of the interval as POSIXct}
##' \item{\code{Midpoint}}{the midpoint of the interval as POSIXct}
##' @export
find.chunk24 <- function(tagdata,threshold) {

  ## Extract date and light data
  date <- tagdata$Date
  light <- tagdata$Light


  ## Calculate light/dark transitions
  l <- (light>=threshold)
  f <- diff(l)
  ab <- which(abs(f)==1)
  ab <- ab+f[ab]==1
  ## Find blocks longer than 24 hrs and return
  tm <- as.numeric(date[ab])
  keep <- which(diff(tm) >= 86400)
  a <- ab[keep]
  b <- ab[keep+1]
  data.frame(Start=date[a],
             End=date[b],
             Midpoint=date[a] + (date[b+1]-date[a])/2)
}




##' Display crepuscular light profiles
##'
##' Interactively displays the light profile for selected twilights.
##' A plot of the estimated times of sunrise and sunset is displayed,
##' the user selects a twilight with the mouse pointer and the light
##' profile for the selected twilight, together with the profiles for
##' the preceeding and following days are shown. This process repeats
##' until no further selections are made.
##'
##' @title Crepuscular light profiles
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights dataframe of twilight times
##' @param offset the starting hour for the vertical axes.
##' @param extend the period (in hours) before and after twilight for
##' which the light profile should be plotted.
##' @param threshold the light threshold that defines twilight.
##' @param twilight.col the colors of the estimated sunrise and sunset times.
##' @param light.col the colors of the light profiles for the day
##' before, the selected twilight and the day after.
##' @param threshold.col the color of the threshold markers
##' @param point.cex expansion factor for plot points.
##' @seealso \code{\link{twilight.edit}}
##' @export
twilight.profiles <- function(tagdata,twilights,
                              offset=0,extend=18,threshold=NULL,
                              twilight.col=c("dodgerblue","firebrick","grey95"),
                              light.col=c("#CCFFCC","black","#CCCCFF"),
                              threshold.col=c("red"),point.cex=0.3) {

  ribbon <- function(start,end,col) {
    shour <- hour.offset(as.hour(start),offset)
    ehour <- hour.offset(as.hour(end),offset)
    ehour <- ifelse(shour < ehour,ehour,ehour+24)
    xs <- c(start,rev(end))
    ys <- c(shour,rev(ehour))
    polygon(xs,ys-24,border=NA,col=col)
    polygon(xs,ys,border=NA,col=col)
    polygon(xs,ys+24,border=NA,col=col)
  }


  ## Extract date and light
  date <- tagdata$Date
  light <- tagdata$Light
  ## Extract date and hour of twilight
  day <- twilights$Twilight
  hour <- hour.offset(as.hour(twilights$Twilight),offset)

  opar <- par(mfrow=c(2,1),mar=c(3,5,1,1))
  ## Make a blank plot
  plot.new()
  ## Plot twilight times and allow user to select twilight
  if(!is.null(twilights$Start) & !is.null(twilights$End)) {
    plot(day,hour,type="n",xlab="Date",ylab="Hour",ylim=c(offset,offset+24))
    ribbon(twilights$Start[twilights$Rise],twilights$End[twilights$Rise],col=twilight.col[1])
    ribbon(twilights$Start[!twilights$Rise],twilights$End[!twilights$Rise],col=twilight.col[2])
    sel <- identify(c(day,day,day),c(hour,hour-24,hour+24),n=1,plot=F)
  } else {
    plot(day,hour,
         pch=16,cex=point.cex,
         xlab="Date",ylab="Hour",
         ylim=c(offset,offset+24),
         col=twilight.col[ifelse(twilights$Rise,1,2)])
    sel <- identify(day,hour,n=1,plot=F)
  }

  ## While the user has selected a twilight
  while(length(sel)>0) {
    sel <- (sel-1)%%length(day)+1
    ## Make light plot for the selected twilight
    twl <- twilights$Twilight[sel]
    keep <- (date >= twl - 3600*extend) & (date <= twl + 3600*extend)
    plot(date[keep],light[keep],xlab="",ylab="Light",type="n",xaxt="n",main=as.character(twl))
    axis.POSIXct(1,x=date[keep],format="%H:%M")
    ## Overlay with light threshold
    if(!is.null(threshold)) {
      abline(v=day[sel],h=threshold,col=threshold.col)
    }
    ## Shade crepuscular period
    if(!is.null(twilights$Start) & !is.null(twilights$End)) {
        rect(twilights$Start[sel],-1,twilights$End[sel],70,border=NA,col=twilight.col[3])
    }
    ## Overlay the light profile for the previous day
    keep <- (date >= twl-86400-3600*extend) & (date <= twl-86400+3600*extend)
    lines(date[keep]+86400,light[keep],type="l",col=light.col[1])
    ## Overlay the light profile for the following day
    keep <- (date >= twl+86400-3600*extend) & (date <= twl+86400+3600*extend)
    lines(date[keep]-86400,light[keep],type="l",col=light.col[3])
    ## Overlay the light profile for the selected twilight again
    keep <- (date >= twl-3600*extend) & (date <= twl+3600*extend)
    lines(date[keep],light[keep],type="l",col=light.col[2])

    ## Plot twilight times and allow user to selected twilight
    if(!is.null(twilights$Start) & !is.null(twilights$End)) {
      plot(day,hour,type="n",xlab="Date",ylab="Hour",ylim=c(offset,offset+24))
      ribbon(twilights$Start[twilights$Rise],twilights$End[twilights$Rise],col=twilight.col[1])
      ribbon(twilights$Start[!twilights$Rise],twilights$End[!twilights$Rise],col=twilight.col[2])
      sel <- identify(c(day,day,day),c(hour,hour-24,hour+24),n=1,plot=F)
    } else {
      plot(day,hour,
           pch=16,cex=point.cex,
           xlab="Date",ylab="Hour",
           ylim=c(offset,offset+24),
           col=twilight.col[ifelse(twilights$Rise,1,2)])
      sel <- identify(day,hour,n=1,plot=F)
    }
  }
  par(opar)
}



##' Interactively edit twilight times
##'
##' Interactively edit times of twilight based on the light profile.
##' A plot of the estimated times of sunrise and sunset is displayed,
##' and the user selects the twilight to be edited with the mouse
##' pointer.  The light profile for the selected twilight, together
##' with the profiles for the preceeding and following days are shown,
##' and the user may select a new time of twilight by clicking on this
##' plot.  Then user may select several new twilight times, but only
##' the final selection is used. This process repeats until no further
##' selections are made.
##'
##' @title Edit twilights
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights dataframe of twilight times as generated by
##' \code{\link{find.twilights}}.
##' @param offset the starting hour for the vertical axes.
##' @param extend the period (in hours) before and after twilight for
##' which the light profile should be plotted.
##' @param threshold the light threshold that defines twilight.
##' @param twilight.col the colors of the estimated sunrise and sunset times.
##' @param light.col the colors of the light profiles for the day
##' before, the selected twilight and the day after.
##' @param threshold.col the color of the threshold markers
##' @param point.cex expansion factor for plot points.
##' @seealso \code{\link{twilight.edit}}
##' @return the dataframe of edited twilights, with columns
##' \item{\code{Twilight}}{edited times of twilight}
##' \item{\code{Rise}}{logical indicating sunrise}
##' \item{\code{Original}}{original times of twilight}
##' @export
twilight.edit <- function(tagdata,twilights,offset=0,extend=18,threshold=NULL,
                           twilight.col=c("dodgerblue","firebrick","grey60"),
                           light.col=c("#CCFFCC","black","#CCCCFF"),
                           threshold.col=c("red"),point.cex=0.3) {
  ## Extract date and light
  date <- tagdata$Date
  light <- tagdata$Light
  ## Extract date and hour of twilight
  day <- twilights$Twilight
  hour <- hour.offset(as.hour(twilights$Twilight),offset)

  ## Record original times
  twilights$Original <- twilights$Twilight
  original.hour <- hour

  opar <- par(mfrow=c(2,1),mar=c(3,5,1,1))
  ## Plot twilight times and allow user to select twilight
  plot(day,hour,
       pch=16,cex=point.cex,
       xlab="Date",ylab="Hour",
       col=twilight.col[ifelse(twilights$Rise,1,2)])
  sel <- identify(day,hour,n=1,plot=F)

  ## While the user has selected a twilight
  while(length(sel)>0) {
    ## Make light plot for the selected twilight
    twl <- twilights$Twilight[sel]
    keep <- (date >= twl - 3600*extend) & (date <= twl + 3600*extend)
    plot(date[keep],light[keep],xlab="",ylab="Light",type="n",xaxt="n",main=as.character(twl))
    axis.POSIXct(1,x=date[keep],format="%H:%M")
    ## Overlay with light threshold
    if(!is.null(threshold)) {
      abline(v=day[sel],h=threshold,col=threshold.col)
    }
    ## Overlay the light profile for the previous day
    keep <- (date >= twl-86400-3600*extend) & (date <= twl-86400+3600*extend)
    lines(date[keep]+86400,light[keep],type="l",col=light.col[1])
    ## Overlay the light profile for the following day
    keep <- (date >= twl+86400-3600*extend) & (date <= twl+86400+3600*extend)
    lines(date[keep]-86400,light[keep],type="l",col=light.col[3])
    ## Overlay the light profile for the selected twilight again
    keep <- (date >= twl-3600*extend) & (date <= twl+3600*extend)
    lines(date[keep],light[keep],type="l",col=light.col[2])
    ## Allow user to select new twilight time
    edit <- locator(type="p",col="grey60",pch=16)
    if(!is.null(edit)) {
      ## Use only final selection
      y <- edit$y[length(edit$y)]
      x <- .POSIXct(edit$x[length(edit$x)],"GMT")
      ## Only update if selected point is inside the plot
      if(y >= 0 & y <= max(light[keep])) {
        twilights$Twilight[sel] <- x
        day <- twilights$Twilight
        hour <- hour.offset(as.hour(twilights$Twilight),offset)
      }
    }
    ## Replot the twilights, with the orginals shown in grey underneath.
    plot(day,hour,pch=16,cex=point.cex, xlab="Date",ylab="Hour",type="n")
    points(day,original.hour,pch=16,cex=point.cex,col=twilight.col[3])
    points(day,hour,pch=16,cex=point.cex,col=twilight.col[ifelse(twilights$Rise,1,2)])
    sel <- identify(day,hour,n=1,plot=F)
  }
  par(opar)
  twilights
}



##' Interactively edit crepuscular intervals
##'
##' Interactively edit the crepuscular intervals based on the light
##' profile.  A plot of the estimated times of sunrise and sunset is
##' displayed, and the user selects the twilight to be edited with the
##' mouse pointer.  The light profile for the selected twilight,
##' together with the profiles for the preceeding and following days
##' are shown, and the user may select a new crepuscular interval by
##' clicking twice on this plot.
##'
##' @title Edit crepuscular
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights dataframe of twilight times as generated by
##' \code{\link{find.crepuscular}}.
##' @param offset the starting hour for the vertical axes.
##' @param extend the period (in hours) before and after twilight for
##' which the light profile should be plotted.
##' @param threshold the light threshold that defines twilight.
##' @param twilight.col the colors of the estimated sunrise and sunset times.
##' @param light.col the colors of the light profiles for the day
##' before, the selected twilight and the day after.
##' @param threshold.col the color of the threshold markers
##' @seealso \code{\link{twilight.edit}}
##' @return the dataframe of edited twilights, with columns
##' \item{\code{Twilight}}{edited times of twilight}
##' \item{\code{Rise}}{logical indicating sunrise}
##' \item{\code{Original}}{original times of twilight}
##' @export
crepuscular.edit <- function(tagdata,twilights,offset=0,extend=4,threshold=NULL,
                           twilight.col=c("dodgerblue","firebrick","grey95"),
                           light.col=c("#CCFFCC","black","#CCCCFF"),
                           threshold.col=c("red")) {

  ribbon <- function(start,end,col) {
    shour <- hour.offset(as.hour(start),offset)
    ehour <- hour.offset(as.hour(end),offset)
    ehour <- ifelse(shour < ehour,ehour,ehour+24)
    xs <- c(start,rev(end))
    ys <- c(shour,rev(ehour))
    polygon(xs,ys-24,border=NA,col=col)
    polygon(xs,ys,border=NA,col=col)
    polygon(xs,ys+24,border=NA,col=col)
  }


  ## Extract date and light
  date <- tagdata$Date
  light <- tagdata$Light
  ## Extract date and hour of twilight
  day <- twilights$Twilight
  hour <- hour.offset(as.hour(twilights$Twilight),offset)

  ## Record original times
  twilights$StartOriginal <- twilights$Start
  twilights$EndOriginal <- twilights$End

  opar <- par(mfrow=c(2,1),mar=c(3,5,1,1))
  ## Plot twilight times and allow user to select twilight
  plot(day,hour,type="n",xlab="Date",ylab="Hour",ylim=c(offset,offset+24))
  ribbon(twilights$Start[twilights$Rise],twilights$End[twilights$Rise],col=twilight.col[1])
  ribbon(twilights$Start[!twilights$Rise],twilights$End[!twilights$Rise],col=twilight.col[2])
  sel <- identify(c(day,day,day),c(hour,hour-24,hour+24),n=1,plot=F)

  ## While the user has selected a twilight
  while(length(sel)>0) {
    sel <- (sel-1)%%length(day)+1
    ## Make light plot for the selected twilight
    twl <- twilights$Twilight[sel]
    keep <- (date >= twl - 3600*extend) & (date <= twl + 3600*extend)
    plot(date[keep],light[keep],xlab="",ylab="Light",type="n",xaxt="n",main=as.character(twl))
    axis.POSIXct(1,x=date[keep],format="%H:%M")
    ## Overlay with light threshold
    if(!is.null(threshold)) {
      abline(h=threshold,col=threshold.col)
    }
    ## Shade crepuscular period
    rect(twilights$Start[sel],-1,twilights$End[sel],70,border=NA,col=twilight.col[3])
    ## Overlay the light profile for the previous day
    keep <- (date >= twl-86400-3600*extend) & (date <= twl-86400+3600*extend)
    lines(date[keep]+86400,light[keep],type="l",col=light.col[1])
    ## Overlay the light profile for the following day
    keep <- (date >= twl+86400-3600*extend) & (date <= twl+86400+3600*extend)
    lines(date[keep]-86400,light[keep],type="l",col=light.col[3])
    ## Overlay the light profile for the selected twilight again
    keep <- (date >= twl-3600*extend) & (date <= twl+3600*extend)
    lines(date[keep],light[keep],type="l",col=light.col[2])

    ## Allow user to select new interval
    edit <- locator(type="n",n=2)
    while(!is.null(edit) & length(edit$x)==2) {
      x <- .POSIXct(sort(edit$x),"GMT")
      x <- date[findInterval(x,date)+c(0,1)]
      twilights$Start[sel] <- x[1]
      twilights$End[sel] <- x[2]
      abline(v=x,col=threshold.col)
      edit <- locator(type="n",n=2)
    }
    ## Plot twilight times and allow user to select twilight
    plot(day,hour,type="n",xlab="Date",ylab="Hour",ylim=c(offset,offset+24))
    ribbon(twilights$Start[twilights$Rise],twilights$End[twilights$Rise],col=twilight.col[1])
    ribbon(twilights$Start[!twilights$Rise],twilights$End[!twilights$Rise],col=twilight.col[2])
    sel <- identify(day,hour,n=1,plot=F)
  }
  par(opar)
  twilights
}



##' Adjust twilight estimates for BAS light recording.
##'
##' BAS tags record the maximum light level observd in the preceding
##' sampling interval, and this behaviour biases naive estimates of
##' the times of sunset.  This function offsets sunset times by the
##' sampling interval to correct for this bias.
##' @title Twilight Adjustment
##' @param twilights dataframe of twilight times
##' @param interval the sampling interval
##' @return a dataframe of bias correct twilight times.
##' @export
twilight.adjust <- function(twilights,interval) {
  twilights$Twilight[!twilights$Rise] <- twilights$Twilight[!twilights$Rise]-interval
  twilights
}



##' Calibrate threshold light level to solar zenith angle
##'
##' Given data for a known location, this plots the recorded light
##' against the solar zenith angle to allow observed light levels to
##' be calibrated to solar zenith angle.
##' @title Light Threshold Calibration
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param lon calibration longitude
##' @param lat calibration latitude
##' @param max.adjust adjust twilights for tags that report the
##' maximum light interval observed in the preceeding sampling
##' interval.
##' @param ... additional arguments to pass to \code{plot}.
##' @export
threshold.calibrate <- function(tagdata,lon,lat,max.adjust=TRUE,...) {
  Light <- tagdata$Light
  Zenith <- zenith(solar(tagdata$Date),lon,lat)
  if(max.adjust) {
    n <- length(Light)
    Light <- Light[-1]
    Zenith <- pmin(Zenith[-1],Zenith[-n])
  }
  plot(Zenith,Light,...)
}


##' Adjust time for clock drift
##'
##' Linearly rescale a sequence of dates to a new start and end time
##' to correct for clock drift in the tag.
##' @title Clock Drift Adjustment
##' @param time a vector of POSIXct times
##' @param start new start time as POSIXct
##' @param end new end time as POSIXct
##' @export
drift.adjust <- function(time,start,end) {
  n <- length(time)
  .POSIXct(approx(time[c(1,n)],c(start,end),time)$y)
}




##' Interactively edit crepuscular intervals
##'
##' Interactively edit the crepuscular intervals based on the light
##' profile.  A plot of the estimated times of sunrise and sunset is
##' displayed, and the user selects the twilight to be edited with the
##' mouse pointer.  The light profile for the selected twilight,
##' together with the profiles for the preceeding and following days
##' are shown in a separate window and the user may select a new
##' crepuscular interval with the mouse. Dragging with the left mouse
##' button depressed selects a new trial interval, which will be
##' displayed in light red. and the user must click the right button
##' to confirm the selection.  The left and right arrow keys can be
##' used to move to the adjacent twilights, and the +/- keys can be
##' used to zoom, and the q key quits and returns the dataframe of
##' edited twilight times.
##'
##' @title Edit crepuscular segments
##' @param tagdata a datframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights dataframe of twilight times as generated by
##' \code{\link{find.crepuscular}}.
##' @param offset the starting hour for the vertical axes.
##' @param extend the period (in hours) before and after twilight for
##' which the light profile should be plotted.
##' @param threshold the light threshold that defines twilight.
##' @param twilight.col the colors of the estimated sunrise and sunset times.
##' @param light.col the colors of the light profiles for the day
##' before, the selected twilight and the day after.
##' @param threshold.col the color of the threshold markers
##' @seealso \code{\link{twilight.edit}}
##' @return the dataframe of edited twilights, with columns
##' \item{\code{Twilight}}{edited times of twilight}
##' \item{\code{Rise}}{logical indicating sunrise}
##' \item{\code{Original}}{original times of twilight}
##' @export
crepuscular.editW <- function(tagdata,twilights,offset=0,extend=6,threshold=NULL,ymax=64,
                              twilight.col=c("dodgerblue","firebrick","grey60"),
                              light.col=c("#CCFFCC","black","#CCCCFF"),
                              threshold.col=c("red")) {

  ## Extract date and light
  date <- tagdata$Date
  light <- tagdata$Light
  ## Extract date and hour of twilight
  day <- twilights$Twilight
  hour <- hour.offset(as.hour(twilights$Twilight),offset)

  ## Record original times
  twilights$StartOriginal <- twilights$Start
  twilights$EndOriginal <- twilights$End

  ## Cached data subsets
  index <- 1
  twl <- NULL
  dteA <- dteB <- dteC <- NULL
  lgtA <- lgtB <- lgtC <- NULL
  x1 <- x2 <- 0
  changed <- FALSE

  ## Set cached values
  cache <- function(k) {
    index <<- k
    twl <<- twilights$Twilight[index]
    x1 <<- twilights$Start[index]
    x2 <<- twilights$End[index]
    keep <- (date >= twl-86400-3600*extend) & (date <= twl-86400+3600*extend)
    dteA <<- date[keep]
    lgtA <<- light[keep]
    keep <- (date >= twl - 3600*extend) & (date <= twl + 3600*extend)
    dteB <<- date[keep]
    lgtB <<- light[keep]
    keep <- (date >= twl+86400-3600*extend) & (date <= twl+86400+3600*extend)
    dteC <<- date[keep]
    lgtC <<- light[keep]
    changed <<- FALSE
  }

  ## Select device
  devset <- function(dev) {
    if(dev.cur()!=dev) dev.set(dev)
  }

  ## Draw the selection window
  select.draw <- function() {
    ribbon <- function(start,end,col) {
      shour <- hour.offset(as.hour(start),offset)
      ehour <- hour.offset(as.hour(end),offset)
      ehour <- ifelse(shour < ehour,ehour,ehour+24)
      xs <- c(start,rev(end))
      ys <- c(shour,rev(ehour))
      polygon(xs,ys-24,border=NA,col=col)
      polygon(xs,ys,border=NA,col=col)
      polygon(xs,ys+24,border=NA,col=col)
    }
    plot(day,hour,type="n",xlab="Date",ylab="Hour",ylim=c(offset,offset+24))
    ribbon(twilights$Start[twilights$Rise],twilights$End[twilights$Rise],col=twilight.col[1])
    ribbon(twilights$Start[!twilights$Rise],twilights$End[!twilights$Rise],col=twilight.col[2])
    points(day[index],hour[index],pch=1)
  }


  ## Draw axes for light profiles
  profile.init <- function() {
    plot(dteB,lgtB,xlab="",ylab="Light",type="n",xaxt="n",main=as.character(twl))
    axis.POSIXct(1,x=dteB,format="%H:%M")
  }

  ## Draw light profiles
  profile.draw <- function() {
    ## Shade selected period
    rect(x1,-1,x2,ymax+1,border=NA,
         col=if(changed) rgb(1.0,0.85,0.85) else "grey95")
    ## Overlay with light threshold
    if(!is.null(threshold))
      abline(h=threshold,col=threshold.col)
    ## Overlay the light profile for the selected and surrounding days
    lines(dteA+86400,lgtA,type="l",col=light.col[1])
    lines(dteC-86400,lgtC,type="l",col=light.col[3])
    lines(dteB,lgtB,type="l",col=light.col[2])
  }


  ## onMouseDown callback for selection window.
  selOnMouseDown <- function(buttons,x,y) {
    ## Determine selected profile.
    devset(select.dev)
    x <- grconvertX(x,from="ndc",to="user")
    y <- grconvertY(y,from="ndc",to="user")
    r <- ((x-as.numeric(day))/3600)^2+((y-hour+12)%%24-12)^2
    k <- which.min(r)
    ## Redraw
    cache(k)
    devset(select.dev)
    select.draw()
    devset(profile.dev)
    profile.init()
    profile.draw()
    bringToTop(profile.dev)
    NULL
  }

  ## onKeybd callback for both windows
  onKeybd <- function(key) {
    ## q quits
    if(key=="q") return(-1)
    ## +/- : zoom time window around threshold crossing
    if(key=="-") {
      extend <<- max(extend-1,1)
      cache(index)
    }
    if(key=="+") {
      extend <<- min(extend+1,24)
      cache(index)
    }
    ## Left/Right : jump to neighbouring twilight
    if(key=="Left") {
      cache(max(index-1,1))
    }
    if(key=="Right") {
      cache(min(index+1,nrow(twilights)))
    }
    ## Redraw
    devset(select.dev)
    select.draw()
    devset(profile.dev)
    profile.init()
    profile.draw()
    NULL
  }

  ## onMouseDown callback for profile window
  prfOnMouseDown <- function(buttons,x,y) {
    ## Button 1 -> record location and do complete draw
    if(length(buttons) > 0 && buttons[1]==0) {
      changed <<- TRUE
      x1 <<- grconvertX(x,from="ndc",to="user")
      x2 <<- x1
      profile.init()
      profile.draw()
    }
    ## Button 2 -> accept new selection
    if(length(buttons) > 0 && buttons[1]==2) {
      twilights$Start[index] <- .POSIXct(x1,"GMT")
      twilights$End[index] <- .POSIXct(x2,"GMT")
      changed <<- FALSE
      profile.draw()
    }
    NULL
  }

  ## onMouseMove callback for profile window
  prfOnMouseMove <- function(buttons,x,y) {
    ## Button 1 drag to select crepuscular period
    if(length(buttons) > 0 && buttons[1]==0) {
      x <- grconvertX(x,from="ndc",to="user")
      if((x > x1 && x < x2) || (x < x1 && x > x2)) profile.init()
      x2 <<- x
      profile.draw()
    }
    NULL
  }

  ## Set up selection window
  index <- 1
  cache(index)
  X11()
  select.draw()
  select.dev <- dev.cur()
  setGraphicsEventHandlers(
    which=select.dev,
    prompt="Select Twilight",
    onMouseDown=selOnMouseDown,
    onKeybd=onKeybd)
  ## Set up profile window
  X11()
  profile.dev <- dev.cur()
  profile.init()
  profile.draw()
  setGraphicsEventHandlers(
    which=profile.dev,
    prompt="Light Profile",
    onMouseDown=prfOnMouseDown,
    onMouseMove=prfOnMouseMove,
    onKeybd=onKeybd)
  ## Monitor for events
  tryCatch({
      getGraphicsEvent()
      dev.off(profile.dev)
      dev.off(select.dev)
      twilights
  }, finally=twilights)
}



