default.palette <- c(red="#E41A1C", blue="#377EB8", green="#4DAF4A", violet="#984EA3",
                     orange="#FF7F00", yellow="#FFFF33", brown="#A65628", pink="#F781BF",
                     black="#000000", grey3="#333333", grey6="#666666", grey9="#999999", greyC="#CCCCCC")




##' Mouse button identification
##'
##' Identify left and right mouse button clicks from the buttons
##' vector passed to the callbacks used by getGraphicsEvent.  This is
##' non-trivial because the windows and MacOS behaviours are subtly
##' different.
##'
##' @title Mouse button identification
##' @param buttons vector passed to callbacks used by getGraphicsEvent.
##' @return Returns 1 for left click, 2 for right click and 0
##' otherwise.
mouse.button <- function(buttons) {
  n <- length(buttons)
  ## This is right click on a mac
  if(n >= 2 && buttons[1]==0 && buttons[2]==1) return(2)

  ## This is both buttons on windows => treat as neither.
  if(n >= 2 && buttons[1]==0 && buttons[2]==2) return(0)

  ## This is right click on windows
  if(n >= 1 && buttons[1]==2) return(2)

  ## This is left click
  if(n >= 1 && buttons[1]==0) return(1)

  ## Other combinations => 0
  0
}




##' Image plot with twilight points and ribbons
##'
##' Draws a light image with twilight points or twilight ribbon. If
##' tagdata is \code{NULL}, no image is drawn.  Twilight points and
##' ribbons are only drawn when twilight data is provided and the
##' point or ribbon colour specifications are non \code{NULL}.
##'
##' @title Image plot with twilights
##' @param tagdata a dataframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights dataframe of twilight times as generated by
##' \code{\link{find.twilights}}.
##' @param offset the starting hour for the vertical axes.
##' @param xlim the range of dates to plot.
##' @param mark twilights to mark with a cross
##' @param points.col colours of twilight points
##' @param ribbon.col colours of twilight ribbons
##' @param lmax the maximum light level to plot.
##' @param point.cex expansion factor for plot points.
image.draw <- function(tagdata=NULL,twilights=NULL,offset=0,xlim=NULL,
                       mark=NULL,points.col=NULL,ribbon.col=NULL,
                       lmax=64,point.cex=0.6) {

  ## Plot background image
  if(!is.null(tagdata)) {
    if(!is.null(xlim))
      light.image(tagdata,offset=offset,lmax=lmax,xlim=xlim)
    else
      light.image(tagdata,offset=offset,lmax=lmax)
  }

  ## If there is twilight data
  if(!is.null(twilights)) {

    day <- twilights$Twilight
    hour <- hour.offset(as.hour(twilights$Twilight),offset)

    ## Initialize plot axes
    if(is.null(tagdata)) plot(day,hour,type="n",xlab="Date",ylab="Hour",ylim=c(offset,offset+24))

    ## Plot twilight times
    if(length(points.col)>0) points(day,hour,pch=16,cex=point.cex,col=points.col)

    ## Plot twilights segments
    if(length(ribbon.col)>0) {
      ribbon.col <- rep(ribbon.col,length.out=2)
      rise <- twilights[twilights$Rise,]
      tsimage.ribbon(.POSIXct(tapply(rise$Start,rise$Twilight,min),"GMT"),
                     .POSIXct(tapply(rise$End,rise$Twilight,max),"GMT"),
                     offset=offset,border=NA,col=ribbon.col[1])
      set <- twilights[!twilights$Rise,]
      tsimage.ribbon(.POSIXct(tapply(set$Start,set$Twilight,min),"GMT"),
                     .POSIXct(tapply(set$End,set$Twilight,max),"GMT"),
                     offset=offset,border=NA,col=ribbon.col[2])
    }
    ## Mark points
    if(length(mark)>0) points(day[mark],hour[mark],pch=3)
  }
}

##' Initialize a light profile plot for plotting
##'
##' Sets up axes for drawing light profile plots.
##'
##' @title Light profile plot
##' @param date a list of three sequences of sample times as POSIXct.
##' @param light a list of three sequences of observed light levels
##' @param lmax the maximum light level.
##' @param xlab the x axis label.
##' @param main the main title.
##' @param threshold threshold levels to display
##' @param point show individual observations as points
##' @param point.cex expansion factor for plot points.
##' @param profile.col the colours of the three light profiles.
##' @param threshold.col the colour of the threshold markers.
profile.init <- function(date,light,lmax=64,xlab="",main="") {
  ## Draw axes for light profiles
  plot(date[[2]],light[[2]],ylim=c(0,lmax),xlab=xlab,ylab="Light",type="n",xaxt="n",main=main)
  axis.POSIXct(1,x=date[[2]],format="%H:%M")
}

##' @rdname profile.init
profile.overlay <- function(date,light,threshold=NULL,point=FALSE,
                            profile.col=default.palette[c(9,5,2)],
                            threshold.col=default.palette[1],
                            point.cex=0.6) {

  ## Overlay with light threshold
  if(!is.null(threshold)) abline(h=threshold,col=threshold.col)
  ## Overlay the light profile for the current and surrounding days
  lines(date[[1]]+86400,light[[1]],col=profile.col[2])
  lines(date[[3]]-86400,light[[3]],col=profile.col[3])
  lines(date[[2]],light[[2]],col=profile.col[1])
  ## Overlay observations.
  if(point) points(date[[2]],light[[2]],col=profile.col[1],pch=16,cex=point.cex)
}

##' Draw rectangle above plot
##'
##' Draws a sequence of rectangles above a plot to indicate sections
##' of the data that have been selected.  Drawing the rectangle above
##' the plot means the selection can be updated without having to
##' redraw the main plot.
##'
##' @title Selection rectangle
##' @param x1 coordinates of the left boundaries of rectangles
##' @param x2 coordinates of the right boundaries of rectangles
##' @param col rectangle colours
##' @param add add rectangles to existing rectangles.
selection.rectangle <- function(x1,x2,col,add=FALSE) {
  ## Determine upper and lower limits
  rx <- grconvertX(c(0,1),from="npc",to="user")
  ry <- grconvertY(c(1.01,1.03),from="npc",to="user")
  ## Over plot with white
  if(!add) rect(rx[1],ry[1],rx[2],ry[2],border=NA,col="white",xpd=NA)
  if(length(x1) >0 && length(x2)>0)
    rect(x1,ry[1],x2,ry[2],border=NA,col=col,xpd=NA)
}



##' Convert ndc coordinates
##'
##' Given user coordinates of a sequence of points and the ndc
##' coordinates (x,y), \code{ndc.closest} returns the index of the
##' closest point to (x,y).  Given the ndc coordinates of a pixel in a
##' tsimage plot, ndc.tsimage.date returns the date of the pixel.
##'
##' @title Graphics coordinate conversion
##' @param x ndc x coordinate
##' @param y ndc y coordinate
##' @param xs points user x coordinates
##' @param ys points user y coordinates
##' @return index of closest point
ndc.closest <- function(x,y,xs,ys) {
  xs <- grconvertX(xs,from="user",to="ndc")
  ys <- grconvertY(ys,from="user",to="ndc")
  which.min((x-xs)^2+(y-ys)^2)
}

##' @rdname ndc.closest
ndc.tsimage.date <- function(x,y) {
  day <- .POSIXct(grconvertX(x,from="ndc",to="user"),"GMT")
  hour <- grconvertY(y,from="ndc",to="user")
  .POSIXct(day+(hour-as.hour(day))*60*60,"GMT")
}


##' Interactively delete observations from a time series
##'
##' Interactively delete observations from a time series.  The time
##' series is displayed. Left mouse button clicks zoom on a region of
##' the plot; right mouse button clicks toggle deletion of individual
##' points.
##'
##' \tabular{ll}{
##' 'q' \tab Quits, returning a indicator vector \cr
##' 'r' \tab Reset zoom to full plot range\cr
##' 's' \tab Toggle reseting of y axes scale on zoom\cr
##' '+'/'-' \tab Adjust the level of zoom\cr
##' 'Left/Right arrow' \tab Jump forward or backward in hte time series \cr
##' }
##'
##'
##' @title Select data
##' @param date sample times.
##' @param r recorded response.
##' @param deleted initial logical vector indicating which
##' observations are to be deleted.
##' @param extend the period (in hours) before and after the selection
##' to be shown in the zoom window.
##' @param xlab label for the x axis
##' @param ylab label for the y axis
##' @param width width of the interface windows.
##' @param height height of the interface windows.
##' @param palette a colour palette of 4 colours.
##' @param ... additional parameters to pass to plot.
##' @return a logical vector that indicates the observations to be deleted.
##' @export
select.data <- function(date,r,deleted=NULL,extend=48,
                        xlab="Date",ylab="",width=12,height=4,
                        palette=default.palette[c(2,1)],...) {

  if(is.null(deleted)) deleted <- logical(length(date))
  zoom <- 3600*extend
  minDate <- min(date)
  maxDate <- max(date)
  xlim <- c(minDate,maxDate)
  ylim <- range(r,na.rm=TRUE)
  rescale <- FALSE


  ## Select device
  set.device <- function(dev) if(dev.cur()!=dev) dev.set(dev)
  ## Focus if possible
  focus <- if(exists("bringToTop",mode="function")) bringToTop else set.device

  ## Draw the selection window
  winA.draw <- function() {
    set.device(winA)
    ## Plot data
    keep <- date >= xlim[1] & date <= xlim[2]
    if(rescale) ylim <<- range(r[keep],na.rm=TRUE)
    plot(date[keep],r[keep],xlab=xlab,ylab=ylab,ylim=ylim,
         col=ifelse(deleted[keep],palette[2],palette[1]),...)
  }

  ## onMouseDown callback for selection window.
  winA.OnMouseDown <- function(buttons,x,y) {
    set.device(winA)

    if(length(buttons) > 0) {
      b <- mouse.button(buttons)
      ## Add segments to include or exclude
      if(b==1) {
        ## Set zoom
        zoom <<- 3600*extend
        x <- grconvertX(x,from="ndc",to="user")
        xlim <<- .POSIXct(x+zoom*c(-1,1),"GMT")
      }
      if(b==2) {
        ## Toggle deletion of closest point
        k <- ndc.closest(x,y,date,r)
        deleted[k] <<- !deleted[k]
      }
      winA.draw()
    }
    NULL
  }

  ## onKeybd callback for both windows
  onKeybd <- function(key) {
    ## q quits
    if(key=="q") return(-1)

    ## r : reset plot
    if(key=="r") {
      xlim <<- c(minDate,maxDate)
      zoom <<- 3600*extend
    }

    if(key=="s") {
      rescale <<- !rescale
      if(!rescale) ylim <<- range(r,na.rm=TRUE)
    }

    ## +/- : expand/shrink zoom
    if(key=="+") {
      zoom <<- zoom/2
      xlim <<- .POSIXct(mean(xlim)+zoom*c(-1,1),"GMT")
    }

    if(key=="-") {
      zoom <<- 2*zoom
      if(zoom < as.numeric(maxDate)-as.numeric(minDate)) {
        xlim <<- .POSIXct(mean(xlim)+zoom*c(-1,1),"GMT")
      } else {
        xlim <<- c(minDate,maxDate)
        zoom <<- 3600*extend
      }
    }

    ## Left/Right : jump to neighbouring chunk
    if(key=="Left") {
      xlim <<- .POSIXct(xlim-2*zoom,"GMT")
      if(xlim[1] < minDate) xlim <<- .POSIXct(c(minDate,minDate+2*zoom),"GMT")
    }
    if(key=="Right") {
      xlim <<- .POSIXct(xlim+2*zoom,"GMT")
      if(xlim[2] > maxDate) xlim <<- .POSIXct(c(maxDate-2*zoom,maxDate),"GMT")
    }
    ## Redraw
    winA.draw()
    NULL
  }

  ## Set up master window
  dev.new(width=width,height=height,noRStudioGD=TRUE)
  winA <- dev.cur()
  winA.draw()
  focus(winA)
  setGraphicsEventHandlers(
    which=winA,
    prompt="Select Data",
    onMouseDown=winA.OnMouseDown,
    onKeybd=onKeybd)
  tryCatch({
    getGraphicsEvent()
    dev.off(winA)
    deleted
  }, finally=deleted)
}

##' Interactively edit crepuscular intervals
##'
##' Interactively edit the crepuscular intervals based on the light
##' profile.  A plot of the estimated sunrise and sunset intervals is
##' displayed, and the user can select the twilight to be edited with
##' a left mouse click.
##'
##' The light profile for the selected twilight is shown in a separate
##' window, and the selected segments of the light profile are
##' highlighted.  The corresponding light profiles from the preceeding
##' and following days are also shown for reference.
##'
##' The user may select a new candidate interval by clicking and
##' dragging with the left mouse button.  Individual points may be
##' selected or deselected with the right mouse button.
##'
##' Note however, no actual change to the selection is made until the
##' candidate edits are accepted depressing the 'a' key.
##'
##' Each twilight may be marked with the an integer 0 to 9 with the
##' numeric keys. By default each day is given the mark 0.
##'
##' In either window
##' \tabular{ll}{
##' 'q' \tab Quits, returning the dataframe of edited twilight segments \cr
##' 'a' \tab Accepts the candidate edit \cr
##' 'r' \tab Resets the selection \cr
##' 'i' \tab Toggles the display of the light image \cr
##' 'p' \tab Toggles the display of individual points \cr
##' '+'/'-' \tab Zoom in or out \cr
##' 'Left arrow' \tab Jump to previous twilight \cr
##' 'Right arrow' \tab Jump to next twilight \cr
##' '0'-'9' \tab Mark this twilight \cr
##' }
##'
##' @title Edit crepuscular segments
##' @param tagdata a dataframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' and light levels recorded by the tag.
##' @param twilights dataframe of twilight times as generated by
##' \code{\link{find.crepuscular}}.
##' @param offset the starting hour for the vertical axes.
##' @param extend the period (in hours) before and after twilight for
##' which the light profile should be plotted.
##' @param threshold the light threshold that defines twilight.
##' @param lmax the maximum light level to plot.
##' @param point.cex expansion factor for plot points.
##' @param width width of the interface windows.
##' @param height height of the interface windows.
##' @param palette a colour palette of 8 colours.
##' @seealso \code{\link{preprocess.light}}
##' @return the dataframe of edited twilights, with columns
##' \item{\code{Twilight}}{edited times of twilight}
##' \item{\code{Rise}}{logical indicating sunrise}
##' \item{\code{Start}}{date of first observation in the crepuscular segment}
##' \item{\code{End}}{date of last observation in the crepuscular segment}
##' @export
crepuscular.edit <- function(tagdata,twilights,offset=0,extend=6,threshold=NULL,lmax=64,
                             point.cex=0.5,width=12,height=4,
                             palette=default.palette[c(5,2,9,3,4,1,1)]) {

  ## Order twilights
  if(is.null(twilights$Marker)) twilights$Marker <- integer(nrow(twilights))
  twilights <- twilights[order(twilights$Twilight,twilights$Start),
                         c("Twilight","Rise","Start","End","Marker")]
  ## Extract date and hour of twilight
  day <- twilights$Twilight
  hour <- hour.offset(as.hour(twilights$Twilight),offset)

  ## Cached data subsets
  index <- 1
  first <- 1
  indices <- as.numeric(factor(as.numeric(twilights$Twilight)))
  date <- vector(3,mode="list")
  lght <- vector(3,mode="list")
  selected <- NULL
  start <- end <- 0
  changed <- FALSE
  show.obs <- FALSE
  show.image <- FALSE

  ## Set cached values
  cache <- function(k) {
    index <<- k
    changed <<- FALSE
    first <<- which(index==indices)[1]
    ## Get profiles
    for(k in 1:3) {
      mid <- twilights$Twilight[index]+(k-2)*86400
      keep <- (tagdata$Date >= mid-3600*extend) & (tagdata$Date <= mid+3600*extend)
      date[[k]] <<- tagdata$Date[keep]
      lght[[k]] <<- tagdata$Light[keep]
    }
    ## Determined selected range
    selected <<- logical(length(date[[2]]))
    for(i in which(index==indices))
      selected[date[[2]] >= twilights$Start[i] & date[[2]] <= twilights$End[i]] <<- TRUE
  }

  ## Select device
  set.device <- function(dev) if(dev.cur()!=dev) dev.set(dev)
  ## Focus if possible
  focus <- if(exists("bringToTop",mode="function")) bringToTop else set.device

  ## Draw the twilights window
  winA.draw <- function() {
    set.device(winA)
    image.draw(if(show.image) tagdata,
               twilights,offset=offset,mark=index,
               ribbon.col=palette[1:2],
               lmax=lmax,point.cex=point.cex)
  }


  ## Draw axes for light profiles
  winB.init <- function() {
    set.device(winB)
    marker <- twilights$Marker[first]
    profile.init(date,lght,lmax=lmax,
                 xlab=if(marker>0) paste("Marker: ",marker) else "",
                 main=as.character(twilights$Twilight[first]))
  }

  ## Draw light profiles
  winB.draw <- function() {
    set.device(winB)
    ## Overlay with light profiles
    profile.overlay(date,lght,threshold,show.obs,
                    profile.col=palette[3:5],threshold.col=palette[6],
                    point.cex=point.cex)

    ## Show selection
    col <- palette[if(changed) 7 else (if(twilights$Rise[first]) 1 else 2)]
    ## Hightlight selected segments
    x <- ifelse(selected,date[[2]],NA)
    y <- ifelse(selected,lght[[2]],NA)
    lines(x,y,col=col)
    if(show.obs) points(x,y,pch=16,cex=point.cex,col=col)

    ## Selection rectangle
    x1 <- x2 <- NULL
    if(any(selected)) {
      x1 <- date[[2]][diff(c(FALSE,selected))==1]
      x2 <- date[[2]][diff(c(selected,FALSE))==-1]
    }
    selection.rectangle(x1,x2,col)
  }


  ## onMouseDown callback for twilights window.
  winA.OnMouseDown <- function(buttons,x,y) {
    set.device(winA)
    if(length(buttons) > 0 && mouse.button(buttons)==1) {
      ## Determine selected profile.
      set.device(winA)
      xs <- grconvertX(c(day,day,day),from="user",to="ndc")
      ys <- grconvertY(c(hour-24,hour,hour+24),from="user",to="ndc")
      k <- (which.min((x-xs)^2+(y-ys)^2)-1)%%length(day)+1
      ## Redraw
      cache(k)
      winA.draw()
      winB.init()
      winB.draw()
      focus(winB)
    }
    NULL
  }

  ## onKeybd callback for both windows
  onKeybd <- function(key) {
    ## q quits
    if(key=="q") return(-1)
    ## +/- : zoom time window around threshold crossing
    if(key=="+") {
      extend <<- max(extend-1,1)
      cache(index)
    }
    if(key=="-") {
      extend <<- min(extend+1,24)
      cache(index)
    }
    ## x : reset selection
    if(key=="r") {
      cache(index)
    }
    ## i : toggle display light image
    if(key=="i") {
      show.image <<- !show.image
    }
    ## p : toggle display of points in the profile window
    if(key=="p") {
      show.obs <<- !show.obs
    }
    ## Left/Right : jump to neighbouring twilight
    if(key=="Left") {
      cache(max(index-1,1))
    }
    if(key=="Right") {
      cache(min(index+1,max(indices)))
    }
    ## a : accept current edit
    if(key=="a") {
      d <- split(twilights,twilights$Twilight)
      d[[index]] <- cbind(Twilight=d[[index]]$Twilight[1],
                          Rise=d[[index]]$Rise[1],
                          data.frame(Start=date[[2]][diff(c(FALSE,selected))==1],
                                     End=date[[2]][diff(c(selected,FALSE))==-1]),
                          Marker=d[[index]]$Marker[1])
      d <- do.call("rbind",d)
      d$Twilight <- .POSIXct(d$Twilight,"GMT")
      d$Start <- .POSIXct(d$Start,"GMT")
      d$End <- .POSIXct(d$End,"GMT")
      twilights <<- d
      indices <<- as.numeric(factor(as.numeric(twilights$Twilight)))
      changed <<- FALSE
    }
    if(key >= "0" && key <= "9") {
      twilights$Marker[which(index==indices)] <<- as.numeric(key)
    }

    ## Redraw
    winA.draw()
    winB.init()
    winB.draw()
    NULL
  }

  ## onMouseDown callback for profile window
  winB.OnMouseDown <- function(buttons,x,y) {
    if(length(buttons) > 0) {
      b <- mouse.button(buttons)
      ## Button 1 -> record location and do complete draw
      if(b==1) {
        changed <<- TRUE
        start <<- grconvertX(x,from="ndc",to="user")
        selected <<- logical(length(date[[2]]))
        end <<- start
        winB.init()
      }
      ## Button 2 -> toggle selected points
      if(b==2) {
        changed <<- TRUE
        xs <- grconvertX(date[[2]],from="user",to="ndc")
        ys <- grconvertY(lght[[2]],from="user",to="ndc")
        k <- which.min((x-xs)^2+(y-ys)^2)
        selected[k] <<- (selected[k]==FALSE)
      }
    }
    winB.draw()
    NULL
  }

  ## onMouseMove callback for profile window
  winB.OnMouseMove <- function(buttons,x,y) {
    ## Button 1 drag to select crepuscular period
    if(length(buttons) > 0 && mouse.button(buttons)==1) {
      end <<- grconvertX(x,from="ndc",to="user")
      sel <- (date[[2]] >= min(start,end) & date[[2]] <= max(start,end))
      if(any(sel!=selected)) {
        selected <<- sel
        winB.draw()
      }
    }
    NULL
  }

  ## Set up twilights window
  index <- 1
  cache(index)
  dev.new(width=width,height=height,noRStudioGD=TRUE)
  winA <- dev.cur()
  winA.draw()
  setGraphicsEventHandlers(
    which=winA,
    prompt="Select Twilight",
    onMouseDown=winA.OnMouseDown,
    onKeybd=onKeybd)
  ## Set up profile window
  dev.new(width=width,height=height,noRStudioGD=TRUE)
  winB <- dev.cur()
  winB.init()
  winB.draw()
  setGraphicsEventHandlers(
    which=winB,
    prompt="Light Profile",
    onMouseDown=winB.OnMouseDown,
    onMouseMove=winB.OnMouseMove,
    onKeybd=onKeybd)
  focus(winA)
  ## Monitor for events
  tryCatch({
      getGraphicsEvent()
      dev.off(winB)
      dev.off(winA)
      twilights
  }, finally=twilights)
}






##' Overlay a data when editing an initial path.
##'
##' The \code{path.edit} function allows the user to specify a
##' function to overlay data on the map to assist is selecting an
##' initial path.
##'
##' This function overlays a contour map of the difference between the
##' observed twilight and true time of twilight for that location and
##' day, where positive and negative contours are shown in different
##' colours.  This can be useful is selecting an initial path for
##' which the residuals are positive.
##'
##' @title Overlay data for path editing
##' @param twilights the full twilight data
##' @param index the index of the current twilight
##' @param mode the overlay mode requested by \code{path.edit}
##' @param xlim the horizontal limits of the map
##' @param ylim the vertical limits of the map
##' @param contours the contour levels to display
##' @param zenith the solar zenith angle that defines twilight
##' @seealso \code{\link{path.edit}}
##' @export
overlay.twilight.residuals <- function(twilights,index,mode,xlim,ylim,
                                       contours=c(10,20,50),zenith=NULL) {
  add.alpha <- function(col,alpha) {
    col <- col2rgb(col)/255
    rgb(red=col[1],green=col[2],blue=col[3],alpha=alpha)
  }

  if(mode!=0 && !is.null(zenith)) {
    grid <- raster(nrows=30,ncols=30,xmn=xlim[1],xmx=xlim[2],ymn=ylim[1],ymx=ylim[2])
    grid <- solar.residuals(twilights$Twilight[index],twilights$Rise[index],grid,zenith=zenith)
    contour(grid,add=TRUE,levels=c(0,contours),col=add.alpha(default.palette[3],0.5))
    contour(grid,add=TRUE,levels=-contours,col=add.alpha(default.palette[4],0.5))
  }
}


##' Interactively edit a path of twilight locations.
##'
##' Interactively edit a path of twilight locations.  A plot of the
##' estimated sunrise and sunset times is displayed, and the user can
##' select the location corresponding to a particular twilight with a
##' left mouse click.
##'
##' The path is dislayed in another window, with the editable location
##' highlighted.  The user can select the point to edit with a left
##' mouse click, or move the editable location with a right mouse
##' click.  In auto advance mode, when a location is edited, the
##' editable location advances to the next location in the sequence.
##'
##' In either window
##' \tabular{ll}{
##' 'q' \tab Quits, returning the dataframe of edited twilight segments \cr
##' 'a' \tab Toggle auto advance mode \cr
##' 'r' \tab Resets the zoom to the encompass the entire track \cr
##' 'c' \tab Centres the zoomed window on the current point \cr
##' 'z' \tab Zooms to the locations surrounding the current location \cr
##' 'u' \tab Resets any edits to the current point \cr
##' '+'/'-' \tab Zoom in or out \cr
##' 'Left arrow' \tab Jump to previous location \cr
##' 'Right arrow' \tab Jump to next location \cr
##' '0'-'9' \tab Set the mode of the overlay plot \cr
##' }
##'
##' The user may supply a function \code{plot.map} that plots a
##' background map.  This must be a function of two arguments
##' \code{xlim} and \code{ylim} the determine the extent of the plot.
##'
##' The user may also supply a function \code{plot.overlay} that
##' overlays twilight specific data on the map.  This must be a
##' function of six arguments, \code{mode} is an integer flag used to
##' indicate the style of the overlay plot, \code{twilights} is the
##' dataframe of twilight data, \code{index} is the index of the
##' current twilight, \code{xlim} and \code{ylim} determine the extent
##' of the plot, and \code{...} is used to pass any additional
##' arguments.  The mode of the overlay plot is set with the keys 0 to
##' 9. We adopt the convention that mode 0 suppresses the overlay, but
##' this is not enforced.
##'
##' The user may also supply a function \code{is.invalid} that accepts
##' the current path as an argument and returns a logical vector
##' indicating which locations along the path are in some way invalid.
##' The twilights for these locations will be highlighted.
##'
##' @title  Adjust a path
##' @param path a two column matrix of the (lon,lat) locations at the
##' twilight times.
##' @param twilights dataframe of twilight times as generated by
##' \code{\link{find.twilights}}.
##' @param offset the starting hour for the vertical axes.
##' @param fixed logical vector indicating which locations to hold
##' fixed.
##' @param aspect aspect ratio of the map.
##' @param extend the number of locations before and after the current
##' location to highlight.
##' @param auto.advance advance to next point afet edit.
##' @param plot.map A function to plot the background map.
##' @param plot.overlay A function to overlay twilight specific data on the map.
##' @param is.invalid A function that indicates if a location is not valid.
##' @param point.cex expansion factor for plot points.
##' @param width width of the selection window.
##' @param height height of the selection window.
##' @param map.width width of the map window.
##' @param map.height height of the map window.
##' @param palette a colour palette of 8 colours.
##' @param ... additional arguments passed to plot.overlay
##' @return a two column matrix of (lon,lat) locations.
##' @export
path.edit <- function(path,twilights,offset=0,fixed=FALSE,
                      aspect=1,extend=1,auto.advance=FALSE,
                      plot.map=NULL,plot.overlay=NULL,
                      is.invalid=function(path) logical(nrow(path)),
                      point.cex=0.5,width=12,height=4,
                      map.width=8,map.height=8,
                      palette=default.palette[c(5,2,1,12,3,4)],
                      ...) {


  ## Store original path
  path0 <- path
  ## Order twilights and check deleted
  twilights <- twilights[order(twilights$Twilight),]
  ## Extract date and hour of twilight
  day <- twilights$Twilight
  hour <- hour.offset(as.hour(twilights$Twilight),offset)
  ## Set fixed points
  fixed <- rep(fixed,length.out=nrow(path))
  invalid <- !fixed & is.invalid(path)
  ## Overlay mode
  mode <- 0


  ## Map scale parameters
  xlim <- ylim <- centre <- xyscl <- NULL
  set.zoom <- function(w) {
    xyscl <<- w
    xlim <<- centre[1]+xyscl*c(-0.5,0.5)
    ylim <<- pmax(pmin(centre[2]+aspect*xyscl*c(-0.5,0.5),90),-90)
    map <<- NULL
  }

  set.window <- function(path) {
    xl <- range(path[,1])
    yl <- range(path[,2])
    centre <<- c(mean(xl),mean(yl))
    set.zoom(max(diff(xl),diff(yl)/aspect))
  }
  set.window(path)
  ## Cached map
  map <- NULL

  if(is.null(plot.map))
    plot.map <- function(xlim,ylim) { plot.new(); plot.window(xlim,ylim) }

  ## Select device
  set.device <- function(dev) if(dev.cur()!=dev) dev.set(dev)
  ## Focus if possible
  focus <- if(exists("bringToTop",mode="function")) bringToTop else set.device

  ## Draw the twilights window
  winA.draw <- function() {
    set.device(winA)
    col <- palette[ifelse(fixed,4,
                          ifelse(is.na(invalid) | invalid,3,
                                 ifelse(twilights$Rise,1,2)))]
    image.draw(NULL,twilights,offset=offset,mark=index,
               points.col=col,point.cex=point.cex)
  }

  ## Draw light profiles
  winB.draw <- function() {
    set.device(winB)
    ## Create underlying map
    if(is.null(map)) {
      ## User defined map function
      plot.map(xlim,ylim)
      map <<- recordPlot()
      p <- par()$usr
      xlim <<- p[1:2]
      ylim <<- p[3:4]
    } else {
      ## Replot stored plot
      replayPlot(map)
    }

    ## Overlays
    if(!is.null(plot.overlay))
      plot.overlay(twilights,index,mode,xlim,ylim,...)
    ## Show full path
    lines(path[,1],path[,2],col=palette[4])
    points(path[,1],path[,2],col=palette[4],pch=16,cex=0.4)
    ## Highlight current point
    ks <- max(1,index-extend):min(nrow(path),index+extend)
    lines(path[ks,1],path[ks,2],col=palette[3])
    points(path[index,1],path[index,2],col=palette[if(fixed[index]) 4 else 3],pch=16,cex=1)
  }

  ## onMouseDown callback for twilights window.
  winA.OnMouseDown <- function(buttons,x,y) {
    set.device(winA)
    ## Determine selected profile.
    index <<- (ndc.closest(x,y,c(day,day,day),c(hour-24,hour,hour+24))-1)%%length(day)+1
    ## Redraw
    winA.draw()
    winB.draw()
    focus(winB)
    NULL
  }

  ## onKeybd callback for both windows
  onKeybd <- function(key) {
    ## q quits
    if(key=="q") return(-1)
    if(key=="a") {
      auto.advance <<- !auto.advance
    }
    ## Reset zoom to the full path
    if(key=="r") {
      set.window(path)
    }
    ## Centre on current point
    if(key=="c") {
      centre <<- path[index,]
      set.zoom(xyscl)
    }

    ## Zoom to locations surrounding current location
    if(key=="z") {
      set.window(path[max(1,index-extend):min(nrow(path),index+extend),])
    }
    ## +/- : zoom map window around current centre
    if(key=="+") {
      set.zoom(5/8*xyscl)
    }
    if(key=="-") {
      set.zoom(8/5*xyscl)
    }
    ## Left/Right : jump to neighbouring twilight
    if(key=="Left") {
      index <<- max(index-1,1)
    }
    if(key=="Right") {
      index <<- min(index+1,nrow(path))
    }
    ## Undo edit - reset to original location
    if(key=="u") {
      path[index,] <<- path0[index,]
    }
    if(key >= "0" && key <= "9") {
      mode <<- key
    }

    ## Redraw
    winA.draw()
    winB.draw()
    NULL
  }

  ## onMouseDown callback for path window
  winB.OnMouseDown <- function(buttons,x,y) {
    set.device(winB)
    if(length(buttons) > 0) {
      b <- mouse.button(buttons)
      ## Button 1 -> select point
      if(b==1) {
        ## Select nearest point
        index <<- ndc.closest(x,y,path[,1],path[,2])
      }
      ## Button 2 -> move location
      if(b==2) {
        if(!fixed[index]) {
          path[index,] <<- c(grconvertX(x,from="ndc",to="user"),
                             grconvertY(y,from="ndc",to="user"))
          invalid <<- !fixed & is.invalid(path)
        }
        if(auto.advance) index <<- min(index+1,nrow(path))
      }
    }
    winA.draw()
    winB.draw()
    NULL
  }

  ## Set up twilights window
  index <- 1
  dev.new(width=width,height=height,noRStudioGD=TRUE)
  winA <- dev.cur()
  winA.draw()
  setGraphicsEventHandlers(
    which=winA,
    prompt="Select Twilight",
    onMouseDown=winA.OnMouseDown,
    onKeybd=onKeybd)
  ## Set up path window
  dev.new(width=map.width,height=map.height,noRStudioGD=TRUE)
  winB <- dev.cur()
  winB.draw()
  setGraphicsEventHandlers(
    which=winB,
    prompt="Path",
    onMouseDown=winB.OnMouseDown,
    onKeybd=onKeybd)
  focus(winA)
  ## Monitor for events
  tryCatch({
    getGraphicsEvent()
    dev.off(winB)
    dev.off(winA)
    path
  }, finally=path)
}




##' Interactively derive and edit twilight times.
##'
##' This function allows the user to interactively search for and edit
##' twilight times corresponding to a given light threshold. The
##' process consists of four stages,
##' \enumerate{
##' \item Subset -- selection of a subset of the data for processing
##' \item Search -- semi-automated search for the twilights
##' \item Insert -- optionally, twilights are inserted where the light record is incomplete
##' \item Edit -- optioanlly, individual twilights are manually adjusted based on the light profiles.
##' }
##'
##' At each stage, user is presented with two windows.  The first
##' shows the data in its entirety and allows the user to select a
##' subset of the data to be manipulated in the second window.
##'
##' In the first stage the user can restrict the data to a subset for
##' processing.  The first window shows a light image and a coloured
##' rectangle above the image shows the selected subset of data.  In
##' the first window, clicking with either mouse button produces a
##' zoomed image of the clicked region in the second window.  In
##' either window, left mouse clicks define the start of the selected
##' subset and right mouse clicks defines the end of the selected
##' subset. The "a" key accepts the current selection an proceeds to
##' the next stage.
##'
##' In either window
##' \tabular{ll}{
##' 'q' \tab Quits\cr
##' 'a' \tab Accepts any changes and advances to the next stage \cr
##' '+'/'-' \tab Zoom in or out \cr
##' }
##'
##' In the second stage the user guides an semi-automated search for
##' the twilight times.  Again, a right mouse click in the first
##' window produces a zoomed image of the clicked region in the
##' second.  In the second window, the user must click in periods of
##' nights.  Left mouse clicks select regions to be searched for
##' twilights, right mouse clicks select regions that should not be
##' searched.  The "u" key provides an undo facility, allowing mouse
##' clicks to be deleted, and the "a" key terminates the search and
##' proceeds to the next stage.
##'
##' In either window
##' \tabular{ll}{
##' 'q' \tab Quits, returning the dataframe of edited twilights\cr
##' 'a' \tab Accepts any changes and advances to the next stage \cr
##' 'u' \tab Removes the most recent search point\cr
##' '+'/'-' \tab Zoom in or out \cr
##' }
##'
##' In the third stage the user may insert additional twilights where
##' the light record is incomplete. As for the first two stages, right
##' mouse clicks in the first window produce a zoomed image of the
##' clicked region in the second window.  In the second window, the
##' user may ad times of sunrise or sunset.  A left mouse click adds a
##' sunset, and a right mouse click adds a sunrise. The numeric keys
##' on the keyboard mark the most recent inerted point with a "mark" 0
##' to 9. If the user provides both the \code{zenith} argument and a
##' two column matrix of locations for the \code{fixed} argument,
##' marking a point with the digit n replaces the marked twilight with
##' the computed twilight time for the n-th fixed location.  Again "u"
##' provides an undo facility and the "a" key proceeds to the next
##' stage.
##'
##' In either window
##' \tabular{ll}{
##' 'q' \tab Quits, returning the dataframe of edited twilight segments \cr
##' 'a' \tab Accepts any changes and advances to the next stage \cr
##' 'u' \tab Removes the most recent insertion \cr
##' '+'/'-' \tab Zoom in or out \cr
##' '0'-'9' \tab Mark the most recent addition \cr
##' }
##'
##' In the fourth stage, the user may adjust individual twilights
##' based on the observed light profile.  The first window now shows
##' the sequence of twilights.  A right mouse click on any twilight
##' shows the light profile for that twilight in the second window,
##' together with the profiles for the preceeding and following days.
##' A left click in the second window proposes a new location for the
##' current twilight, but no change is made until the edit is accepted
##' with the "a" key. A right click in the second window marks the
##' twilight as deleted, and the numeric keys mark the twilight with a
##' "mark" 0 to 9. If the user provides both the \code{zenith}
##' argument and a two column matrix of locations for the \code{fixed}
##' argument, marking a point with the digit n replaces the marked
##' twilight with the computed twilight time for the n-th fixed
##' location.  The "u" key reverts the edits to the current twilight.
##'
##' In either window
##' \tabular{ll}{
##' 'q' \tab Quits, returning the dataframe of edited twilight segments \cr
##' 'a' \tab Accepts the candidate edit \cr
##' 'd' \tab Toggle deletion of this twilight \cr
##' 'i' \tab Toggles the display of the light image \cr
##' 'p' \tab Toggles the display of individual points \cr
##' 'r' \tab Resets the selection \cr
##' 'u' \tab Revert changes to this twilight \cr
##' '+'/'-' \tab Zoom in or out \cr
##' 'Left arrow' \tab Jump to previous twilight \cr
##' 'Right arrow' \tab Jump to ext twilight \cr
##' '0'-'9' \tab Mark this twilight \cr
##' }
##'
##'
##' @title Interactively derive twilight
##' @param tagdata a dataframe with columns \code{Date} and
##' \code{Light} that are the sequence of sample times (as POSIXct)
##' @param threshold the light threshold that defines twilight.
##' @param offset the starting hour for the vertical axes.
##' @param lmax the maximum light level to plot.
##' @param extend a time in minutes. The function seeks periods of
##' darkness that differ from one another by 24 hours plus or minus
##' this interval.
##' @param dark.min a time in minutes. Periods of darkness shorter
##' than this interval will be excluded.
##' @param zenith the solar zenith angle that defines twilight.
##' @param fixed a two column array of fixed locations
##' @param point.cex expansion factor for plot points.
##' @param width width of the interface windows.
##' @param height height of the interface windows.
##' @param palette a colour palette of 7 colours.
##' @return A dataframe with columns
##' \item{\code{Twilight}}{times of twilight}
##' \item{\code{Rise}}{logical indicating sunrise}
##' \item{\code{Deleted}}{logical indentifying deleted twilights}
##' \item{\code{Marker}}{integer vector of marks}
##' \item{\code{Inserted}}{logical vector of marks}
##'\item{\code{Twilight3}}{Twilight from stage 3}
##' \item{\code{Marker3}}{Marker from stage 3}
##' where each row corresponds to a single twilight.
##' @importFrom SGAT twilight
##' @export
preprocess.light <- function(tagdata,threshold,offset=0,lmax=64,
                             extend=0,dark.min=0,
                             zenith=96,fixed=NULL,
                             point.cex=0.8,width=12,height=4,
                             palette=default.palette[c(5,2,9,3,4,1,13)]) {

  twilights <- NULL

  ## Round down/up to nearest offset
  floorDate <- function(date) date - ((as.hour(date)-offset)%%24)*60*60
  ceilingDate <- function(date) date + ((offset-as.hour(date))%%24)*60*60

  ## Set initial selection to entire date range
  minDate <- floorDate(min(tagdata$Date))
  maxDate <- ceilingDate(max(tagdata$Date))
  Date1 <- minDate
  Date2 <- maxDate
  DateZ <- NULL

  seed <- include <- NULL
  zoom <- 6

  ## Cached data subsets
  stage <- 1
  index <- NULL
  edit.pt <- NULL
  changed <- FALSE
  twls <- NULL
  date <- vector(3,mode="list")
  lght <- vector(3,mode="list")
  show.obs <- FALSE
  show.image <- FALSE


  ## Set cached values
  cache <- function(k) {
    index <<- k
    edit.pt <<- NULL
    changed <<- FALSE
    ## Get twilight times
    twl <- twilights$Twilight[index]
    keep <- (twilights$Twilight >= twl-3600*zoom) & (twilights$Twilight <= twl+3600*zoom)
    keep[index] <- FALSE
    twls <<- twilights$Twilight[keep]
    ## Get profiles
    for(k in 1:3) {
      mid <- twilights$Twilight[index]+(k-2)*86400
      keep <- (tagdata$Date >= mid-3600*zoom) & (tagdata$Date <= mid+3600*zoom)
      date[[k]] <<- tagdata$Date[keep]
      lght[[k]] <<- tagdata$Light[keep]
    }
  }



  ## Select device
  set.device <- function(dev) if(dev.cur()!=dev) dev.set(dev)
  ## Focus if possible
  focus <- if(exists("bringToTop",mode="function")) bringToTop else set.device


  ## Draw the twilights window
  winA.draw <- function() {
    set.device(winA)
    image.draw(if(stage < 4 || show.image) tagdata,
               twilights,offset=offset,mark=index,
               points.col=palette[ifelse(twilights$Deleted,7,ifelse(twilights$Rise,1,2))],
               lmax=lmax,point.cex=point.cex)
    title(main=switch(stage,
            "Select subset",
            "Find twilights",
            "Insert twilights",
            "Edit twilights"))

    if(stage==1)
      selection.rectangle(Date1,Date2,col=palette[6])

    if(stage==2 && length(include)>0)
      tsimage.points(seed,offset=offset,pch=16,col=palette[ifelse(include,4,5)])
  }


  winB.draw <- function() {
    set.device(winB)
    if(stage <= 3) {
      ## Display zoomed image
      xlim <- if(!is.null(DateZ)) {
        start <- floorDate(max(DateZ - zoom*24*60*60,minDate))
        end <- ceilingDate(min(start+2*zoom*24*60*60,maxDate))
        start <- floorDate(max(end - 2*zoom*24*60*60,minDate))
        c(start,end)
      }
      image.draw(tagdata,twilights,offset=offset,
                 points.col=palette[ifelse(twilights$Rise,1,2)],
                 lmax=lmax,xlim=xlim)
      title(main=as.character(DateZ))
    } else {
      ## Plot light profiles
      marker <- twilights$Marker[index]
      profile.init(date,lght,lmax=lmax,
                   xlab=if(marker>0) paste("Marker: ",marker) else "",
                   main=as.character(twilights$Twilight[index]))
      ## Overlay with light profiles
      profile.overlay(date,lght,threshold,show.obs,
                      profile.col=palette[3:5],threshold.col=palette[6],
                      point.cex=point.cex)
      abline(v=twls,col=palette[7])
      abline(v=twilights$Twilight[index],col=if(!twilights$Deleted[index]) palette[6] else palette[7])
      if(changed) points(edit.pt[1],edit.pt[2],pch=16,col=palette[6])
    }

    if(stage==1)
      tsimage.points(c(Date1,Date2),offset=offset,pch=16,col=palette[6])

    if(stage==2 && length(include)>0)
      tsimage.points(seed,offset=offset,pch=16,col=palette[ifelse(include,4,5)])
  }


  ## onMouseDown callback for twilights window.
  winA.OnMouseDown <- function(buttons,x,y) {
    set.device(winA)
    if(length(buttons) > 0) {
      b <- mouse.button(buttons)

      if(stage==1) {
        ## Set endpoints and zoom window B
        if(b==1) {
          Date1 <<- ndc.tsimage.date(x,y)
          if(Date1 > Date2) Date2 <<- maxDate
          DateZ <<- Date1
        }
        if(b==2) {
          Date2 <<- ndc.tsimage.date(x,y)
          if(Date2 < Date1) Date1 <<- minDate
          DateZ <<- Date2
        }
      }

      if(stage==2 || stage==3) {
        ## Zoom window B.
        if(b==1) {
          DateZ <<- ndc.tsimage.date(x,y)
        }
      }

      if(stage==4) {
        ## Determine selected profile.
        if(b==1) {
          day <- twilights$Twilight
          hour <- hour.offset(as.hour(twilights$Twilight),offset)
          k <- (ndc.closest(x,y,c(day,day,day),c(hour-24,hour,hour+24))-1)%%length(day)+1
          ## Redraw
          cache(k)
        }
      }
    }

    winA.draw()
    winB.draw()
    NULL
  }


  ## onMouseDown callback for profile window
  winB.OnMouseDown <- function(buttons,x,y) {
    set.device(winB)

    if(length(buttons) > 0) {
      b <- mouse.button(buttons)
      if(stage==1) {
        ## Set endpoint and zoom
        if(b==1) {
          Date1 <<- ndc.tsimage.date(x,y)
          if(Date1 > Date2) Date2 <<- maxDate
        }
        if(b==2) {
          Date2 <<- ndc.tsimage.date(x,y)
          if(Date2 < Date1) Date1 <<- minDate
        }
      }

      if(stage==2) {
        ## Add segments to include or exclude
        if(b==1 || b==2) {
          seed <<- c(ndc.tsimage.date(x,y),seed)
          include <<- c(buttons[1]==0,include)

          ## Recompute twilights
          twilights <<- find.twilights(tagdata,threshold=threshold,
                                       include=seed[include],exclude=seed[!include],
                                       extend=extend,dark.min=dark.min)
          twilights$Deleted <<- logical(nrow(twilights))
          twilights$Marker <<- integer(nrow(twilights))
          twilights$Inserted <<- logical(nrow(twilights))

        }
      }

      if(stage==3) {
        ## Add twilights
        if(b==1) {
          twilights <<- rbind(twilights,
                              data.frame(Twilight=ndc.tsimage.date(x,y),
                                         Rise=FALSE,
                                         Deleted=FALSE,
                                         Marker=0,
                                         Inserted=TRUE))
        }
        if(b==2) {
          twilights <<- rbind(twilights,
                              data.frame(Twilight=ndc.tsimage.date(x,y),
                                         Rise=TRUE,
                                         Deleted=FALSE,
                                         Marker=0,
                                         Inserted=TRUE))
        }
      }

      if(stage==4) {
        ## Button 1 -> record location
        if(b==1) {
          changed <<- TRUE
          edit.pt <<- c(grconvertX(x,from="ndc",to="user"),
                        grconvertY(y,from="ndc",to="user"))
        }
        ## Button 2 -> toggle deletion
        if(b==2) {
          twilights$Deleted[index] <<- !twilights$Deleted[index]
          cache(index)
        }
      }
    }
    winA.draw()
    winB.draw()
    NULL
  }


  ## onKeybd callback for both windows
  onKeybd <- function(key) {
    ## Common keybindings
    ## q : quit
    if(key=="q") {
      if(!is.null(twilights)) {
        twilights <<- twilights[order(twilights$Twilight),]
        attr(twilights,"interval") <- c(minDate,maxDate)
      }
      return(-1)
    }
    ## +/- : zoom time window around threshold crossing
    if(key=="+") {
      zoom <<- max(zoom-2,1)
      if(stage==4) cache(index)
    }
    if(key=="-") {
      zoom <<- min(zoom+2,24)
      if(stage==4) cache(index)
    }

    if(stage==1) {
      ## Stage 1 keybindings
      ## a : accept and advance to next stage
      if(key=="a") {
        minDate <<- Date1
        maxDate <<- Date2
        tagdata <<- tagdata[tagdata$Date >= minDate & tagdata$Date <= maxDate,]
        DateZ <<- NULL
        stage <<- 2
      }
    } else if(stage==2) {
      ## Stage 2 keybindings
      ## a : accept and advance to next stage
      if(key=="a") {
        index <<- 1
        DateZ <<- NULL
        stage <<- 3
      }
      if(key=="u") {
        if(length(seed)>0) {
          seed <<- seed[-1]
          include <<- include[-1]

          ## Recompute twilights
          twilights <<- find.twilights(tagdata,threshold=threshold,
                                       include=seed[include],exclude=seed[!include],
                                       extend=extend,dark.min=dark.min)
          twilights$Deleted <<- logical(nrow(twilights))
          twilights$Marker <<- integer(nrow(twilights))
          twilights$Inserted <<- logical(nrow(twilights))
        }
      }
    } else if(stage==3) {
      ## Stage 3 keybindings
      ## a : accept and advance to next stage
      if(key=="a") {
        twilights$Twilight3 <<- twilights$Twilight
        twilights$Marker3 <<- twilights$Marker
        ks <- order(twilights$Twilight)
        twilights <<- twilights[ks,]
        cache(ks[index])
        zoom <<- 6
        stage <<- 4
      }
      ## u : undo twilight insertions
      if(key=="u") {
        n <- nrow(twilights)
        if(twilights$Inserted[n]) twilights <<- twilights[-n,]
        index <<- nrow(twilights)
      }
      ## Markers
      if(key >= "0" && key <= "9") {
        marker <- as.numeric(key)
        index <<- nrow(twilights)
        twilights$Marker[index] <<- marker
        if(marker > 0 && marker <= NROW(fixed))
          twilights$Twilight[index] <<- twilight(twilights$Twilight[index],
                                                 fixed[marker,1],fixed[marker,2],
                                                 rise=twilights$Rise[index],
                                                 zenith=zenith)
      }
    } else if(stage==4) {
      ## Stage 4 keybindings
      ## a : accept changes
      if(key=="a") {
        twilights$Twilight[index] <<- .POSIXct(edit.pt[1],"GMT")
        edit.pt <<- NULL
        changed <<- FALSE
      }
      ## i : toggle image display
      if(key=="i") {
        show.image <<- !show.image
      }
      ## x : reset selection
      if(key=="r") {
        cache(index)
      }
      ## d : toggle deletion
      if(key=="d") {
        twilights$Deleted[index] <<- !twilights$Deleted[index]
      }
      ## p : toggle display of points in the profile window
      if(key=="p") {
        show.obs <<- !show.obs
      }
      ## u : undo edits
      if(key=="u") {
        twilights$Twilight[index] <<- twilights$Twilight3[index]
        twilights$Marker[index] <<- twilights$Marker3[index]
      }
      ## Left/Right : jump to neighbouring twilight
      if(key=="Left") {
        cache(max(index-1,1))
      }
      if(key=="Right") {
        cache(min(index+1,nrow(twilights)))
      }
      ## Markers
      if(key >= "0" && key <= "9") {
        marker <- as.numeric(key)
        twilights$Marker[index] <<- marker
        if(marker > 0 && marker <= NROW(fixed))
          twilights$Twilight[index] <<- twilight(twilights$Twilight[index],
                                                 fixed[marker,1],fixed[marker,2],
                                                 rise=twilights$Rise[index],
                                                 zenith=zenith)
      }
    }

    ## Redraw
    winA.draw()
    winB.draw()
    NULL
  }


  ## Set up twilights window
  dev.new(width=width,height=height,noRStudioGD=TRUE)
  winA <- dev.cur()
  winA.draw()
  setGraphicsEventHandlers(
    which=winA,
    prompt="Selection Window",
    onMouseDown=winA.OnMouseDown,
    onKeybd=onKeybd)
  ## Set up profile window
  dev.new(width=width,height=height,noRStudioGD=TRUE)
  winB <- dev.cur()
  winB.draw()
  setGraphicsEventHandlers(
    which=winB,
    prompt="Edit Window",
    onMouseDown=winB.OnMouseDown,
    onKeybd=onKeybd)
  focus(winA)
  ## Monitor for events
  tryCatch({
      getGraphicsEvent()
      dev.off(winB)
      dev.off(winA)
      twilights
  }, finally=twilights)
}

